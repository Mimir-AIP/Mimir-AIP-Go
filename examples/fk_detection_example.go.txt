package main

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/Mimir-AIP/Mimir-AIP-Go/pipelines/Ontology/schema_inference"
)

func main() {
	fmt.Println("=== Foreign Key Detection Example ===\n")

	// Create inference engine with FK detection enabled
	config := schema_inference.InferenceConfig{
		SampleSize:          100,
		EnableConstraints:   true,
		EnableFKDetection:   true, // Enable FK detection
		FKMinConfidence:     0.8,  // 80% minimum confidence
		EnableRelationships: true,
	}

	engine := schema_inference.NewSchemaInferenceEngine(config)

	// Example 1: E-commerce data with clear FK relationships
	fmt.Println("Example 1: E-commerce Orders")
	fmt.Println("------------------------------")

	orders := []map[string]interface{}{
		{"order_id": 1001, "user_id": 10, "product_id": 500, "quantity": 2, "status": "shipped"},
		{"order_id": 1002, "user_id": 11, "product_id": 501, "quantity": 1, "status": "pending"},
		{"order_id": 1003, "user_id": 10, "product_id": 502, "quantity": 3, "status": "delivered"},
		{"order_id": 1004, "user_id": 12, "product_id": 500, "quantity": 1, "status": "shipped"},
		{"order_id": 1005, "user_id": 11, "product_id": 503, "quantity": 2, "status": "pending"},
	}

	ordersSchema, err := engine.InferSchema(orders, "orders")
	if err != nil {
		log.Fatalf("Failed to infer orders schema: %v", err)
	}

	printSchemaInfo(ordersSchema)

	// Example 2: Blog data with multiple FK relationships
	fmt.Println("\nExample 2: Blog Posts")
	fmt.Println("------------------------------")

	posts := []map[string]interface{}{
		{"id": 1, "title": "Introduction to Go", "author_id": 100, "category_id": 1, "created_by_id": 100},
		{"id": 2, "title": "Advanced Patterns", "author_id": 101, "category_id": 1, "created_by_id": 101},
		{"id": 3, "title": "Database Design", "author_id": 100, "category_id": 2, "created_by_id": 100},
		{"id": 4, "title": "API Development", "author_id": 102, "category_id": 1, "created_by_id": 100},
	}

	postsSchema, err := engine.InferSchema(posts, "posts")
	if err != nil {
		log.Fatalf("Failed to infer posts schema: %v", err)
	}

	printSchemaInfo(postsSchema)

	// Example 3: Detecting different FK patterns
	fmt.Println("\nExample 3: Various FK Naming Patterns")
	fmt.Println("------------------------------")

	mixedData := []map[string]interface{}{
		{"id": 1, "user_id": 10, "org_ref": 100, "fk_manager": 5, "parent_id": 0},
		{"id": 2, "user_id": 11, "org_ref": 100, "fk_manager": 5, "parent_id": 1},
		{"id": 3, "user_id": 10, "org_ref": 101, "fk_manager": 6, "parent_id": 1},
	}

	mixedSchema, err := engine.InferSchema(mixedData, "employees")
	if err != nil {
		log.Fatalf("Failed to infer mixed schema: %v", err)
	}

	printSchemaInfo(mixedSchema)

	// Example 4: Generate ontology from schema with FKs
	fmt.Println("\nExample 4: Ontology Generation")
	fmt.Println("------------------------------")

	ontologyConfig := schema_inference.OntologyConfig{
		BaseURI:         "http://example.com/ontology/",
		OntologyPrefix:  "ex",
		IncludeMetadata: true,
		IncludeComments: true,
		ClassNaming:     "pascal",
		PropertyNaming:  "camel",
	}

	generator := schema_inference.NewOntologyGenerator(ontologyConfig)
	ontology, err := generator.GenerateOntology(ordersSchema)
	if err != nil {
		log.Fatalf("Failed to generate ontology: %v", err)
	}

	fmt.Printf("Generated Ontology: %s\n", ontology.Name)
	fmt.Printf("Classes: %d\n", len(ontology.Classes))
	fmt.Printf("Properties: %d\n", len(ontology.Properties))

	// Show ObjectProperties created from FKs
	fmt.Println("\nObject Properties (from FKs):")
	for _, prop := range ontology.Properties {
		if prop.Type == "object" {
			fmt.Printf("  - %s: %s -> %s\n", prop.Name, prop.Domain, prop.Range)
			fmt.Printf("    Description: %s\n", prop.Description)
		}
	}

	// Show a snippet of the OWL content
	fmt.Println("\nOWL Content Preview (first 500 chars):")
	if len(ontology.Content) > 500 {
		fmt.Println(ontology.Content[:500] + "...")
	} else {
		fmt.Println(ontology.Content)
	}
}

func printSchemaInfo(schema *schema_inference.DataSchema) {
	fmt.Printf("Schema: %s\n", schema.Name)
	fmt.Printf("Columns: %d\n", len(schema.Columns))

	// Print column information
	fmt.Println("\nColumns:")
	for _, col := range schema.Columns {
		flags := []string{}
		if col.IsPrimaryKey {
			flags = append(flags, "PK")
		}
		if col.IsForeignKey {
			flags = append(flags, "FK")
		}
		if col.IsUnique {
			flags = append(flags, "UNIQUE")
		}
		if col.IsRequired {
			flags = append(flags, "REQUIRED")
		}

		flagStr := ""
		if len(flags) > 0 {
			flagStr = fmt.Sprintf(" [%s]", joinStrings(flags, ", "))
		}

		fmt.Printf("  - %s (%s)%s\n", col.Name, col.DataType, flagStr)

		if col.Cardinality > 0 {
			fmt.Printf("    Cardinality: %d (%.1f%%)\n", col.Cardinality, col.CardinalityPercent*100)
		}

		if col.FKMetadata != nil {
			fmt.Printf("    FK Metadata:\n")
			fmt.Printf("      Referenced Column: %s\n", col.FKMetadata.ReferencedColumn)
			fmt.Printf("      Confidence: %.2f\n", col.FKMetadata.Confidence)
			fmt.Printf("      Detection Method: %s\n", col.FKMetadata.DetectionMethod)
		}
	}

	// Print FK relationships
	if len(schema.ForeignKeys) > 0 {
		fmt.Printf("\nForeign Key Relationships: %d\n", len(schema.ForeignKeys))
		for i, fk := range schema.ForeignKeys {
			fmt.Printf("  %d. %s -> %s\n", i+1, fk.SourceColumn, fk.TargetColumn)
			fmt.Printf("     Confidence: %.2f\n", fk.Confidence)
			fmt.Printf("     Referential Integrity: %.1f%% (%d/%d values match)\n",
				fk.ReferentialIntegrity*100, fk.MatchedValues, fk.TotalValues)
			fmt.Printf("     Detection Methods: %s\n", joinStrings(fk.DetectionMethods, ", "))
		}
	}

	// Print metadata
	fmt.Println("\nMetadata:")
	metadataJSON, _ := json.MarshalIndent(schema.Metadata, "  ", "  ")
	fmt.Printf("  %s\n", string(metadataJSON))
}

func joinStrings(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}
